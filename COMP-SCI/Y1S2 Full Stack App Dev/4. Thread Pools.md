Thread pools are used to deal with situations where we have a large amount of computations / services to be performed in a shrot space of time. We instantiate lots of threads, and put them in a blocked state, waiting for input.

The reason for this is that thread creation, deletion and switching is computationally expensive.

Thread pools also known as replicated workers or worker-crew model, refers to a collection of (mostly identical) threads waiting for tasks to be allocated for concurrent execution by some supervising program. 
Rationale: 
	-Instead of creating service threads on demand, have a pool of them ready to respond to a service request. 
	-The pool size i.e. the number of threads, may be dynamically adjusted based on the number of waiting tasks

Thread pools consist of a task queue and group of worker threads. Service tasks are queued and attended when a pooled worker thread becomes available.
![[chrome_Rsv3r2Qvxr.jpg]]
In practice, thread pools are often implemented with a FIFO queue.

The main thread only manages the work queue, each worker checks for work in the queue:
![[Pasted image 20230220180932.png]]

Thread pools are a software pattern design. They increase performance and avoid latency in execution due to frequent creation and destruction of threads for short-lived, highly-frequent tasks. Thread pools regulate the number of concurrent threads.

There can be some complications:
	**Thread-pool capacity**: can be too large (unnecessary memory) or too small (sluggish responsiveness).
	**Tasks queue capacity**: can be fixed length, but difficult to make large enough for the max needed, but small enough to be memory efficient, or variable length, which can cause out of memory issues if the queue task keeps increasing.
	**Competing with parallel programming**: parallel programming may be more suitable for the tasks a thread-pool is used for.


**Thread pools in Java**

Java has a `ExecutorService` interface in the java.util package, which is used to manage thread pools with methods for assigning tasks to them. The easiest way to instantiate a `ExecutorService` is to use one of the several factory methods: `AbstractExecutorService, ForkJoinPool, ScheduledThreadPoolExecutor and ThreadPoolExecutor as well as subinterfaces, i.e. ScheduledExecutorService.` These are each used for creating `ExecutorService` objects for meeting different needs.

![[chrome_IUst6Zyc54.jpg]]
*An example of a basic thread pool*

To assign a task to the `ExecutorService`, the task must be a `Runnable` and/or `Callable` object. 

For `runnable` tasks:
```
executorService.execute(runnableTask)
```

For `Callable` tasks:
```
Future<String>future = executorService.submit(callableTask);
String result = executorService.invokeAny(callableTasks); 
List <Future<String>>futures = executorService.invokeAll(callableTasks);
```

To shut down the `ExecutorService`, we can either call the `.shutdown()` method which allows previously submitted tasks to execute before terminating, or the `.shutdownNow()` method, which prevents waiting tasks for starting and further attempts to stop currently executing tasks.

```
### .shutdown method ###

executorService.shutdown();

### .shutdownNow method ###

List<Runnable> notExecutedTasks = executorService.shutDownNow();
```

