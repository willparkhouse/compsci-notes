Databases are classically characterized as either relational databases (collection of tables) or non-relational databases (key-value DB, graph DB, XML DB, document stores). 

Databases organize data according to a data model, which is a collection of concepts used to describe the structure of a database by:
	Encoding the database **abstraction**
	Provides details of data **organization** and storage
	Includes (explicitly or implicitly) **operations** for specifying retrievals and updates on the database
	Describes the **dynamic behaviour** of a database

The part of the **data model** that *describes* the data is called the **schema** (pl. schemata), the example below shows the titles of the columns constituting the schema.

Example of a schema.
![[chrome_3EPtG1LVTh.jpg]]

**Relational Databases**

**Relational databases** are collections of n-ary relations, where the associations forming the relation are stored or represented as tables.

Each **table** represents a relation, and in particular, its rule of association.
Each **column** of a table represents a domain, but it is often referred to as an *attribute*. 
Each **row** of a table represents a specific *association*, case or tuple; often referred to as a *record*.

A bad choice of when to add new tables or columns may need to non-optimal solutions; **redundancy**. 
Redundancy can occur due to repeating data in multiple places, storing derived attributes (a form of aggregation, sometimes useful for insight extraction, or adding checksums.) 

Redundancy is not *always* a bad thing, a small amount of controlled, intentional redundancy might be beneficial.

In general, redundancy is undesirable because of extra storage required in memory and disk, and management of data is more prone to error, as we may need to update many records when one attribute changes. Redundancy can be useful to; protect against attacks (eg. checksums), increase temporal efficiency when derived attributes are expensive to compute, and to improve the performance of queries.

Another undesirable DB design feature is allowing multiple associations, e.g. having a cell containing an array of values; this means that a query on that column will have to iterate through all the records arrays.

**The Entity-Relationship Model**

The design of a database is concerned with solving; 
	Data requirements - what data is stored and how it is stored; inc specifying the data model
	Functional requirements - how the data evolves and is accessed and maintained.

The ER model describes data in terms of;
	**entities** or mathematical object, i.e. anything you can want/need to define
	**relationships** between entities
	**attributes**, properties of the entities (i.e. domains of the relation)
		a collection of entities sharing the same attributes is called an entity type; analogous to a class in OOP.

Entities are mostly relations. Relationships are also relations. Practically, you can think of entities as nouns and relationships as verbs.

*Example of an ER model:*
![[chrome_r5wegaBegW.jpg]]

We can represent our ER model diagrammatically like so:
![[chrome_CnyN091wzb.jpg]]

With each symbol meaning: ![[chrome_dVvKhWP4aX.jpg]]

The underlined attributes are keys; 
single valued attributes (can only take one value for an entity) are single ellipse, but notice the *department* attribute may be multivalued, and be represented with a double ellipse; 
the dashed outline around *city* denotes that it is a derived attribute; 
attributes can have sub-attributes, like *address* above, which itself has atomic attributes (postcode, street, No.) 

Cardinality or *multiplicity* constrains how many entities may participate in the relationship, and is denoted with:
![[chrome_T8LwmPNB2w.jpg]]
Going FROM the relationship TOWARDS the constraint entity type.

**Database Management Systems (DBMS)**
Computer based databases are managed through database management systems (DBMS). They take care of defining, maintaining, constructing, manipulating, sharing, securing and protecting the database. A DBMS catalogue is a directory of information about the data sets, files and databases managed by the DBMS. 

A *view* is an access to a subset of the information contained in the database. For practical purposes, a view is a virtual table built from the base tables stored in the database; it can contain information stored directly in the database and/or derived from the database.

Views are used to read from (querying) or writing to the database. A view can access information from a single table, or multiple at once. 

**DBMS Transactions**
A *unit of work* is any manipulation of the database; e.g. a collection of read or write operations, that is conceptually monolithic. A database **transaction** is a unit of work executed by a DBMS (This may involve one or more operations, but we must either do ALL or NONE or them to maintain database consistency.) 

Suppose that you want to get cash from an ATM. This transaction involves at least several more basic operations; ---Ensuring that you have sufficient credit in your account at the beginning of the transaction. 
-Ensuring that you are not going over your day limit. 
-Ensuring that the ATM has sufficient money to attend your cash request. 
-Subtracting the withdrawn amount from your account balance, and 
-Handling you the money. 
If only a few of these are executed, then the database may be left inconsistent.

Transaction's desirable properties include:
**Atomic** – The transaction is treated as a unit; it either works completely or fails completely.
**Consistent** – Guarantee that the database remains correct. It prevents database corruption by an illegal transaction. However, it does not guarantee that a given transaction is correct (those which are not correct, will simply fail).
**Isolated** – Even if executed concurrently with other transactions, the database ought to be left in the same state that it would have, should that transaction had been executed alone.
**Durable** – If the transaction is successful, then its effects will remain committed even in the case of a system failure (e.g. power outage or crash)
These properties together are often referred to as **ACID**.

**Constraints and Triggers**

Integrity **constraints** are mathematical restrictions ruling what values are allowed to be inserted in a relation and ensure that data remains correct. They can be coarsely grouped as:
-**Implicit**: those enforced by the data model (e.g. storing the name of an actor in a database about cars, things the model can't handle)
-**Explicit**: those enforced by the schema (e.g. AGE > 18 for a database of adults)
-**Semantic**: those enforced by the application (invariants)

Examples of some simple constraints, that require an attribute to hold certain values, or certain formats:
	Age must be bigger than 18yo.
	A UK phone number ought to have 11 digits.
	A car plate cannot be null. 
	Your fingerprint image is perhaps not a key, yet it has to be unique.

Constraints enforce correct and consistent values, but not necessarily correct values:
	Suppose that you have a database for holding student markings. An integrity constraint has been specified that the course marking must be a figure between 0 and 10. John is a good student and scored an 9, but alas the lecturer by mistake typed a 7, and since 7 abides by the integrity constraint, the database will be updated with the wrong value.

Common SQL constraints:
![[chrome_IDQ10SyNkf.jpg]]

DBMS Triggers are procedures that automatically launch when a certain condition is met, like 'IF ... THEN ...' rules.

**Keys**

A key is a minimal uniqueness constraint on attributes. 
	-**Uniqueness** implies that it holds for every association of the relation. 
	-**Minimal** implies that superfluous attributes must not be included in a key, but neither any attribute can be removed without destroying uniqueness.

A table may have more than one key. Each one of these keys is called a **candidate key**. A **primary key** is a key arbitrarily chosen among the candidate keys. **Primary keys** will be used to link records **between different relations**. The presence of some primary key in a different table is referred to as a **foreign key**.

It follows that:
	A key cannot be NULL
	A key value must be unique
	The primary key values should rarely be changed
	The primary key must be given a value when a new record is inserted.

![[Pasted image 20230310161248.png]]

