Client Server is a computational model describing a distributed asymmetric cooperation of entities.

![[chrome_8KwDTcmm2R.jpg]]

Client-server architecture is architecturally opposed to P2P networks.

The server entity provides a service, and the client entity requests or consumes the service. A service is a computational resource; e.g. a task.

The client-server model assumes that the entities;
	Each client knows at least one server, and further that they can communicate with each other.
	Each client and each server is autonomous, that is, each one has its own local memory (CPU, HDD, Compute could theoretically be shared)

In the architecture there is no assumption in the model about:
	The number of clients and the number of servers; although a typical architecture will see a n:1 relation
	Separation of the processes; physical or logical, other that the system being distributed, i.e. the components are not the same process
		-most times, this means different computers connected through some network
	The number of services provided by any server, or the number of services consumed by the clients

To communicate, client-server architecture employ a two-way communication stream:
![[chrome_mkYlbgDGeI.jpg]]
In general, each end of the steam is identified by a port, and specifically, when the client-server model is implemented over a network, the communication stream links two sockets (a port + IP address)

A port is a logical identifier assigned to processes, so they can be referenced within the system.

A socket is a port with an IP address; it identifies an application and is bound to a port number.

By means of the socket, the Open Systems Interconnection (OSI's) network model transport layer of the network can identify the application that data is destined to be sent to.

**Multithreaded servers**

Regardless of the number of clients, the server stays waiting to receive requests from clients. There is no certainty on the number or timing of the requests. Upon receiving a request, the server attends the request and communicates back to the client, the outcome of its request.

Ideally, the client should perceive the server as responsive. So although a server can, in principle, consist of a single thread with a queue of requests and attend them sequentially, it is far more commons to implement concurrent multithreaded servers. Multithreaded servers create one thread to attend to each client and handle each individual request. These threads are often referred to as service threads.

![[chrome_AMKL51T5TJ.jpg]]

