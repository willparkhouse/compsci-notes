There are many different architectures for operating systems:

**Traditional UNIX** - one big kernel
	-Consists of everything below the system-call interface and above the physical hardware
	-Provides the file system, CPU scheduling, memory management, and other operating-system functions; a large number of functions for one level.
	-Limited to hardware support compiled into the kernel.
![](Images/Obsidian_PQXXpVfnZ2.jpg)

**Microkernel**
-Moves as much as possible from the kernel into less privileged “user” space (e.g. file system, device drivers, etc.) 
-Communication takes place between user modules using message passing 
	-The device driver for, say, a hard disk device can run all logic in user space (e.g. decided when to switch on and off the motor, queuing which sectors to read next, etc.) 
	-But when it needs to talk directly to hardware using privileged I/O port instructions, it must pass a message requesting such to the kernel.

Benefits: 
	-Easier to **develop** microkernel extensions 
	-Easier to **port the operating system** to new architectures 
	-**More reliable** (less code is running in kernel mode) - if a device driver fails, it can be re-loaded 
	-**More secure**, since kernel is less-complex and therefore less likely to have security holes. 
	-The system can recover from a failed device driver, which would usually cause “a blue screen of death” in Windows or a “kernel panic” in linux. 
Drawbacks: 
	-Performance overhead of user space to kernel space communication
	 
The Minix OS and L3/L4 are examples of microkernel architecture:
![](Images/Obsidian_4F907n9UK6.jpg)

**Modular Kernel**
Most modern operating systems implement kernel modules 
	-Uses object-oriented–like approach 
	-Each core component is separate 
	-Each talks to the others over known interfaces 
	-Each is loadable as needed within the kernel, so you could download a new device driver for your OS and load it at run-time, or perhaps when a device is plugged in 
Overall, similar to layered architecture but with more flexibility, since all require drivers or kernel functionality need not be compiled into the kernel binary. 

## Virtual Machines

A virtual machine allows you 
## Linux Device Drivers
