Previously all the technique for encryption we looked at are **symmetric key** encryption, where both participants have the same private key. This becomes an issue when wanting to speak to many people, or more technically servers (as we do nowadays), so instead we can use public key cryptography, where every user has a public / private key pair. We need to store / receive the public keys of participants, but this is not protected information, and we never need to share private keys. 

**Message integrity** is a property that verifies that the message is untampered with - we can use **signatures** to do this. We can sign a message using a signing algorithm and our private key, and the receiver can be verify the signature using our public key.

Now lets say we want to make sure that a public key is genuine. The way this works usually is that we have a **trusted oracle** (certificate authority), with a globally known public key, this authorities key is often bundled with the operating system, and is taken to be genuine. This authority then signs certificates (usually of certificate issuers), and then these issuers can provide a signature for keys, to ensure genuineness. 

![](Images/chrome_M2aPYYvAxz.png)

#### Multi Round Solution to Secure Key Exchange
In order to verify the public key, we can use a **multi-round solution**. This involves encrypting our public key in a "two sided lock box", and sending this to our recipient, they then lock with their key pair and send it back, we then decrypt our side, the "box" (our public key) is now secured only with the recipients public key - once sent, they can decrypt it to get access to the public key.

The system described above is a very simple implementation of a multi-round solution, but this can be extended to also include authentication, key agreement, and other features. A very common implementation of a multi-round solution is **TLS**.

![](Images/chrome_SewLzpJleG.png)
#### Diffie Hellman Key Exchange
Another version of key exchange is the Diffie Hellman key exchange system. This involves picking a relatively large number $p$, and $g$, which is small prime number. $p$ is very large, often 2048 or 4096 bits - the size of $p$ is necessary for good security. Alice picks a number between 2 and $p$-2 at random, she then calculates $A = g^a mod (p)$. A is then sent to Bob. Bob picks another number between 2 and $p$-2 at random, and works out $B = g^b mod (p)$, and sends this to Alice. A quirk of modular arithmetic is that when we raise a number like A to b, like $A^b$, this is equal to $B^a$. Both parties do this, and the resulting number is a shared key. 

![](Images/chrome_REQfAmbbL1.png)
*A visualisation of DHKE.*

DHKE is susceptible to a **man-in-the-middle** attack. This is where a third-party intercepts the A and B, and falsifies that it is each other party. 
![](Images/chrome_JvULRNOCpa.png)

We can solve this using RSA.
#### RSA
